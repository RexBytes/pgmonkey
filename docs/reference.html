<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pgmonkey - Reference Guide</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-color: #f4f4f4;
        }
        header {
            background-color: #007BFF;
            color: #fff;
            padding: 20px 0;
            text-align: center;
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        nav {
            margin-top: 20px;
        }
        nav a {
            margin: 0 15px;
            text-decoration: none;
            color: #fff;
            font-weight: bold;
        }
        .content {
            width: 80%;
            margin: 0 auto;
            padding: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        footer {
            padding: 20px;
            text-align: center;
            background-color: #007BFF;
            color: #fff;
            margin-top: 40px;
        }
        h2 {
            margin-top: 40px;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <header>
        <h1>pgmonkey - Reference Guide</h1>
        <nav>
            <a href="index.html">Home</a>
            <a href="https://github.com/RexBytes/pgmonkey">GitHub</a>
            <a href="https://pypi.org/project/pgmonkey/">PyPI</a>
            <a href="https://github.com/RexBytes/pgmonkey/blob/main/README.md">Documentation</a>
            <a href="reference.html">Quick Reference</a>
            <a href="compatibility_tests.html">Dependency Compatibility Tests</a>
        </nav>
    </header>

    <div class="content">
        <h2>CLI Commands Overview</h2>
        <table>
            <thead>
                <tr>
                    <th>Command</th>
                    <th>Description</th>
                    <th>Example Usage</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>pgmonkey settings</td>
                    <td>Manage application settings.</td>
                    <td><code>pgmonkey settings --help</code></td>
                </tr>
                <tr>
                    <td>pgmonkey pgconfig create</td>
                    <td>Create a new PostgreSQL configuration template.</td>
                    <td><code>pgmonkey pgconfig create --connconfig config.yaml</code></td>
                </tr>
                <tr>
                    <td>pgmonkey pgconfig test</td>
                    <td>Test a database connection using a configuration file.</td>
                    <td><code>pgmonkey pgconfig test --connconfig config.yaml --connection-type pool</code></td>
                </tr>
                <tr>
                    <td>pgmonkey pgconfig generate-code</td>
                    <td>Generate example Python code for a connection type.</td>
                    <td><code>pgmonkey pgconfig generate-code --connconfig config.yaml --connection-type async</code></td>
                </tr>
                <tr>
                    <td>pgmonkey pgserverconfig</td>
                    <td>Generate PostgreSQL server configuration recommendations.</td>
                    <td><code>pgmonkey pgserverconfig --connconfig config.yaml</code></td>
                </tr>
                <tr>
                    <td>pgmonkey pgimport</td>
                    <td>Import data from a CSV or text file into a specified PostgreSQL table.</td>
                    <td><code>pgmonkey pgimport --table public.my_table --connconfig config.yaml --import_file /path/to/data.csv</code></td>
                </tr>
                <tr>
                    <td>pgmonkey pgexport</td>
                    <td>Export data from a specified PostgreSQL table into a CSV file.</td>
                    <td><code>pgmonkey pgexport --table public.my_table --connconfig config.yaml --export_file /path/to/output.csv</code></td>
                </tr>
            </tbody>
        </table>

<h2>One Config File, All Connection Types</h2>

<p>In pgmonkey v2.0.0, a <strong>single YAML configuration file</strong> serves all connection types. You specify the connection type when calling the API, or let it default to the value in the config file.</p>

<pre><code>from pgmonkey import PGConnectionManager

manager = PGConnectionManager()

# Same config file, different connection types
conn = manager.get_database_connection('config.yaml', 'normal')
conn = manager.get_database_connection('config.yaml', 'pool')
conn = await manager.get_database_connection('config.yaml', 'async')
conn = await manager.get_database_connection('config.yaml', 'async_pool')
</code></pre>

<h2>YAML Configuration Options</h2>

        <h3>Full YAML Configuration</h3>
<pre><code>postgresql:
  # Default connection type when none is specified in the API call.
  # Options: 'normal', 'pool', 'async', 'async_pool'
  # You can override this per-call:
  #   manager.get_database_connection('config.yaml', 'pool')
  connection_type: 'normal'

  connection_settings:
    user: 'postgres'
    password: 'password'
    host: 'localhost'
    port: '5432'
    dbname: 'mydatabase'
    sslmode: 'prefer'  # Options: disable, allow, prefer, require, verify-ca, verify-full
    sslcert: ''  # Path to the client SSL certificate, if needed
    sslkey: ''  # Path to the client SSL key, if needed
    sslrootcert: ''  # Path to the root SSL certificate, if needed
    connect_timeout: '10'  # Maximum wait for connection, in seconds
    application_name: 'myapp'
    keepalives: '1'  # Enable TCP keepalives (1=on, 0=off)
    keepalives_idle: '60'  # Seconds before sending a keepalive probe
    keepalives_interval: '15'  # Seconds between keepalive probes
    keepalives_count: '5'  # Max keepalive probes before closing the connection

  # Settings for 'pool' connection type
  pool_settings:
    min_size: 5
    max_size: 20
    max_idle: 300  # Seconds a connection can remain idle before being closed
    max_lifetime: 3600  # Seconds a connection can be reused

  # Settings for 'async' connection type (applied via SET commands on connection)
  async_settings:
    idle_in_transaction_session_timeout: '5000'  # Timeout for idle in transaction (ms)
    statement_timeout: '30000'  # Cancel statements exceeding this time (ms)
    lock_timeout: '10000'  # Timeout for acquiring locks (ms)
    # work_mem: '256MB'  # Memory for sort operations and more

  # Settings for 'async_pool' connection type
  async_pool_settings:
    min_size: 5
    max_size: 20
    max_idle: 300
    max_lifetime: 3600
</code></pre>

<table>
    <thead>
        <tr>
            <th>Parameter</th>
            <th>Description</th>
            <th>Example Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>postgresql.connection_type</td>
            <td>Default connection type (normal, pool, async, async_pool). Can be overridden per API call.</td>
            <td><code>'normal'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.user</td>
            <td>Username to connect to the PostgreSQL database.</td>
            <td><code>'postgres'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.password</td>
            <td>Password for the database user.</td>
            <td><code>'your password'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.host</td>
            <td>Database server host address.</td>
            <td><code>'localhost'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.port</td>
            <td>Database server port.</td>
            <td><code>'5432'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.dbname</td>
            <td>Name of the PostgreSQL database to connect to.</td>
            <td><code>'mydatabase'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.sslmode</td>
            <td>SSL mode for securing the connection (e.g., disable, allow, prefer, require, verify-ca, verify-full).</td>
            <td><code>'prefer'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.sslcert</td>
            <td>Path to the client SSL certificate, if needed for secure connections.</td>
            <td><code>'/path/to/client.crt'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.sslkey</td>
            <td>Path to the client SSL key, if needed for secure connections.</td>
            <td><code>'/path/to/client.key'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.sslrootcert</td>
            <td>Path to the root SSL certificate, if needed to verify the server's SSL certificate.</td>
            <td><code>'/path/to/ca.crt'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.connect_timeout</td>
            <td>Maximum time in seconds to wait for a connection.</td>
            <td><code>'10'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.application_name</td>
            <td>Application name to report to the PostgreSQL server.</td>
            <td><code>'myapp'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.keepalives</td>
            <td>Enables or disables TCP keepalives (1 to enable, 0 to disable).</td>
            <td><code>'1'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.keepalives_idle</td>
            <td>Time in seconds before sending a keepalive probe.</td>
            <td><code>'60'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.keepalives_interval</td>
            <td>Time in seconds between sending keepalive probes.</td>
            <td><code>'15'</code></td>
        </tr>
        <tr>
            <td>postgresql.connection_settings.keepalives_count</td>
            <td>Maximum number of keepalive probes to send before closing the connection.</td>
            <td><code>'5'</code></td>
        </tr>
        <tr>
            <td>postgresql.pool_settings.min_size</td>
            <td>Minimum number of connections in the pool.</td>
            <td><code>5</code></td>
        </tr>
        <tr>
            <td>postgresql.pool_settings.max_size</td>
            <td>Maximum number of connections in the pool.</td>
            <td><code>20</code></td>
        </tr>
        <tr>
            <td>postgresql.pool_settings.max_idle</td>
            <td>Maximum idle time (in seconds) for connections before they are closed.</td>
            <td><code>300</code></td>
        </tr>
        <tr>
            <td>postgresql.pool_settings.max_lifetime</td>
            <td>Maximum lifetime (in seconds) a connection can be reused before being closed.</td>
            <td><code>3600</code></td>
        </tr>
        <tr>
            <td>postgresql.async_settings.idle_in_transaction_session_timeout</td>
            <td>Maximum time (in milliseconds) that a session can be idle in a transaction before being terminated.</td>
            <td><code>'5000'</code></td>
        </tr>
        <tr>
            <td>postgresql.async_settings.statement_timeout</td>
            <td>Maximum time (in milliseconds) to wait for a statement to execute before canceling it.</td>
            <td><code>'30000'</code></td>
        </tr>
        <tr>
            <td>postgresql.async_settings.lock_timeout</td>
            <td>Maximum time (in milliseconds) to wait for a lock before timing out.</td>
            <td><code>'10000'</code></td>
        </tr>
        <tr>
            <td>postgresql.async_settings.work_mem</td>
            <td>Memory to be used for sorts, hash tables, and similar operations (e.g., 256MB).</td>
            <td><code>'256MB'</code></td>
        </tr>
        <tr>
            <td>postgresql.async_pool_settings.min_size</td>
            <td>Minimum number of connections in the asynchronous pool.</td>
            <td><code>5</code></td>
        </tr>
        <tr>
            <td>postgresql.async_pool_settings.max_size</td>
            <td>Maximum number of connections in the asynchronous pool.</td>
            <td><code>20</code></td>
        </tr>
        <tr>
            <td>postgresql.async_pool_settings.max_idle</td>
            <td>Maximum idle time (in seconds) for asynchronous connections before they are closed.</td>
            <td><code>300</code></td>
        </tr>
        <tr>
            <td>postgresql.async_pool_settings.max_lifetime</td>
            <td>Maximum lifetime (in seconds) an asynchronous connection can be reused before being closed.</td>
            <td><code>3600</code></td>
        </tr>
    </tbody>
</table>



        <h2>Working with PGConnectionManager</h2>
        <p>In <code>pgmonkey</code>, users interact with the PostgreSQL connection using the <code>PGConnectionManager</code> class, which simplifies both synchronous and asynchronous database connections. Use a single YAML configuration file and specify the connection type as a parameter.</p>

        <h3>Basic Usage</h3>
<pre><code>from pgmonkey import PGConnectionManager

# Normal (synchronous) connection
def main():
    manager = PGConnectionManager()
    connection = manager.get_database_connection('config.yaml', 'normal')

    with connection as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT version();')
            print(cur.fetchone())

if __name__ == "__main__":
    main()
</code></pre>

<pre><code>import asyncio
from pgmonkey import PGConnectionManager

# Async connection
async def main():
    manager = PGConnectionManager()
    connection = await manager.get_database_connection('config.yaml', 'async')

    async with connection as conn:
        async with conn.cursor() as cur:
            await cur.execute('SELECT version();')
            print(await cur.fetchone())

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>

        <h3>Working with Transactions, Commit, Rollback, and Cursors</h3>

<p>With <code>pgmonkey</code>, managing connections, transactions, handling commits, rollbacks, and using cursors is simplified for both synchronous and asynchronous connections.</p>

<h4>Connection</h4>
<p>Managing connections in <code>pgmonkey</code> is simplified with context managers, allowing you to use <code>async with</code> or <code>with</code> to handle both connection opening and closing automatically.</p>

<h5>Example Usage:</h5>
<pre><code>
# Asynchronous Connection
    async with connection as conn:
        try:
            async with conn.cursor() as cur:
                await cur.execute('INSERT INTO my_table (name) VALUES (%s)', ('Alice',))
                await cur.execute('SELECT * FROM my_table WHERE name = %s', ('Alice',))
                print(await cur.fetchall())

# Synchronous Connection
    with connection as conn:
        try:
            with conn.cursor() as cur:
                cur.execute('INSERT INTO my_table (name) VALUES (%s)', ('Bob',))
                cur.execute('SELECT * FROM my_table WHERE name = %s', ('Bob',))
                print(cur.fetchall())
</code></pre>

<h4>Transactions</h4>
<p>Transactions allow you to execute a series of SQL statements as a single unit of work.</p>

<h5>Example Usage:</h5>
<pre><code>
# Asynchronous Transaction
async with connection as conn:
    async with conn.transaction():
        async with conn.cursor() as cur:
            await cur.execute('INSERT INTO my_table (name) VALUES (%s)', ('John',))
            await cur.execute('SELECT * FROM my_table WHERE name = %s', ('John',))
            print(await cur.fetchall())

# Synchronous Transaction
with connection as conn:
    with conn.transaction():
        with conn.cursor() as cur:
            cur.execute('INSERT INTO my_table (name) VALUES (%s)', ('Jane',))
            cur.execute('SELECT * FROM my_table WHERE name = %s', ('Jane',))
            print(cur.fetchall())
</code></pre>

<h4>Commit</h4>
<p>The <code>commit()</code> method saves changes made during a transaction. Within a <code>transaction()</code> context, commits are automatic. Use <code>commit()</code> manually outside of the transaction context when needed.</p>

<h5>Example Usage:</h5>
<pre><code>
# Manual commit (if not using transaction context)
async with connection as conn:
    async with conn.cursor() as cur:
        await cur.execute('UPDATE my_table SET name = %s WHERE id = %s', ('Doe', 1))
    await conn.commit()
</code></pre>

<h4>Rollback</h4>
<p>The <code>rollback()</code> method discards all changes made during a transaction.</p>

<h5>Example Usage:</h5>
<pre><code>
# Manual rollback (if not using transaction context)
try:
    async with connection as conn:
        async with conn.cursor() as cur:
            await cur.execute('DELETE FROM my_table WHERE id = %s', (1,))
            raise Exception('Simulated error')
        await conn.commit()
except Exception as e:
    print(f"Error occurred: {e}. Rolling back...")
    await conn.rollback()
</code></pre>

<h4>Cursors</h4>
<p>Cursors execute SQL queries and retrieve results. The cursor context automatically closes the cursor after the block is exited.</p>

<h5>Example Usage:</h5>
<pre><code>
# Asynchronous Cursor
async with connection as conn:
    async with conn.cursor() as cur:
        await cur.execute('SELECT * FROM my_table WHERE name = %s', ('John',))
        rows = await cur.fetchall()
        for row in rows:
            print(row)

# Synchronous Cursor
with connection as conn:
    with conn.cursor() as cur:
        cur.execute('SELECT * FROM my_table WHERE name = %s', ('Jane',))
        rows = cur.fetchall()
        for row in rows:
            print(row)
</code></pre>

<h4>Key Points</h4>
<ul>
    <li>Transactions ensure atomicity of operations, making sure that a series of operations either all succeed or fail together.</li>
    <li>Automatic commit/rollback within a <code>transaction()</code> context eliminates the need for manual commit management in most scenarios.</li>
    <li>The <code>cursor()</code> method is straightforward for executing queries, and works seamlessly with both synchronous and asynchronous operations.</li>
</ul>


        <h3>Example: Testing Pooling Capability</h3>
<pre><code>import asyncio
from pgmonkey import PGConnectionManager

# Function to test multiple async pool connections
async def test_multiple_async_pool_connections(config_file, num_connections):
    manager = PGConnectionManager()
    connections = []

    for _ in range(num_connections):
        connection = await manager.get_database_connection(config_file, 'async_pool')
        connections.append(connection)

    for idx, connection in enumerate(connections):
        async with connection as conn:
            async with conn.cursor() as cur:
                await cur.execute('SELECT version();')
                version = await cur.fetchone()
                print(f"Async Connection {idx + 1}: {version}")

    for connection in connections:
        await connection.disconnect()

# Function to test multiple sync pool connections
def test_multiple_sync_pool_connections(config_file, num_connections):
    manager = PGConnectionManager()
    connections = []

    for _ in range(num_connections):
        connection = manager.get_database_connection(config_file, 'pool')
        connections.append(connection)

    for idx, connection in enumerate(connections):
        with connection as conn:
            with conn.cursor() as cur:
                cur.execute('SELECT version();')
                version = cur.fetchone()
                print(f"Sync Connection {idx + 1}: {version}")

    for connection in connections:
        connection.disconnect()

async def main():
    config_file = '/path/to/config.yaml'
    num_connections = 5

    print("Testing async pool connections:")
    await test_multiple_async_pool_connections(config_file, num_connections)

    print("\nTesting sync pool connections:")
    test_multiple_sync_pool_connections(config_file, num_connections)

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>

<h2>Testing Your Connection Configurations with pgmonkey CLI</h2>

<p>pgmonkey provides a <strong>command-line interface (CLI)</strong> that allows users to quickly test their PostgreSQL connection configurations without needing to write any code.</p>

<h3>How to Use the CLI to Test a Connection</h3>

<pre><code>
# Test using the default connection_type from the config file
pgmonkey pgconfig test --connconfig /path/to/config.yaml

# Test a specific connection type (overrides config file)
pgmonkey pgconfig test --connconfig /path/to/config.yaml --connection-type pool
pgmonkey pgconfig test --connconfig /path/to/config.yaml --connection-type async
</code></pre>

<p>The <code>--connection-type</code> flag accepts: <code>normal</code>, <code>pool</code>, <code>async</code>, <code>async_pool</code>.</p>

<h3>Example Commands with Test Results</h3>

<pre><code>
# Test a normal connection
pgmonkey pgconfig test --connconfig ~/config.yaml --connection-type normal

Output:
Connection successful:  (1,)
Connection closed.
Connection test completed successfully.

# Test an asynchronous connection
pgmonkey pgconfig test --connconfig ~/config.yaml --connection-type async

Output:
Async connection successful:  (1,)
Connection closed.
Connection test completed successfully.

# Test a pooled connection
pgmonkey pgconfig test --connconfig ~/config.yaml --connection-type pool

Output:
Pool connection successful:  (1,)
Pooling test successful: Acquired 6 connections out of a possible 20
Pooling tested successfully with 6 concurrent connections.
Connection test completed successfully.

# Test an asynchronous pooled connection
pgmonkey pgconfig test --connconfig ~/config.yaml --connection-type async_pool

Output:
Async pool connection successful:  (1,)
Pooling test successful: Acquired 6 connections out of a possible 20
Async pooling tested successfully with 6 concurrent connections.
Connection test completed successfully.
</code></pre>

<h3>Other CLI Commands</h3>

<ul>
    <li><code>pgmonkey pgconfig create</code>: Create a new configuration template.</li>
    <li><code>pgmonkey pgconfig generate-code</code>: Generate example Python code to connect using your configuration file. Supports <code>--connection-type</code> flag.</li>
    <li><code>pgmonkey pgserverconfig</code>: Generate server configuration recommendations based on your YAML file.</li>
    <li><code>pgmonkey pgimport</code>: Import data from a CSV or text file into a PostgreSQL table.</li>
    <li><code>pgmonkey pgexport</code>: Export data from a PostgreSQL table to a CSV file.</li>
</ul>


<p>For more information on how to use the CLI, run the <code>--help</code> command:</p>

<pre><code>
pgmonkey --help
</code></pre>

<h2>Importing and Exporting Data</h2>

<p>This section covers the usage of the <code>pgmonkey</code> command-line tool for importing and exporting data with PostgreSQL.</p>

<h3>Importing Data</h3>
<p>The <code>pgimport</code> command allows you to import CSV or text files into a specified PostgreSQL table.</p>

<h4>Usage:</h4>
<pre><code>pgmonkey pgimport --table &lt;TABLE&gt; --connconfig &lt;CONFIG_FILE&gt; --import_file &lt;IMPORT_FILE&gt;</code></pre>

<h4>Options:</h4>
<ul>
    <li><strong>--import_file</strong>: The path to the CSV file or text file that you want to import into the database.</li>
    <li><strong>--table</strong> (required): The target table name in the database. You can specify it as <code>schema.table</code> or just <code>table</code>.</li>
    <li><strong>--connconfig</strong> (required): The path to the connection configuration file.</li>
</ul>

<h4>Example Command:</h4>
<pre><code>pgmonkey pgimport --table public.my_table --connconfig /path/to/config.yaml --import_file /path/to/data.csv</code></pre>

<h4>Note:</h4>
<ul>
    <li>If an import configuration file (YAML) doesn't exist, a template will automatically be generated for you. You can edit this template to adjust settings such as column mapping, delimiter, or encoding before running the import again.</li>
</ul>

<h3>Exporting Data</h3>
<p>The <code>pgexport</code> command allows you to export data from a PostgreSQL table into a CSV file.</p>

<h4>Usage:</h4>
<pre><code>pgmonkey pgexport --table &lt;TABLE&gt; --connconfig &lt;CONFIG_FILE&gt; [--export_file &lt;CSV_FILE&gt;]</code></pre>

<h4>Options:</h4>
<ul>
    <li><strong>--table</strong> (required): The name of the table you want to export from the database. Specify as <code>schema.table</code> or just <code>table</code>.</li>
    <li><strong>--connconfig</strong> (required): The path to the connection configuration file.</li>
    <li><strong>--export_file</strong> (optional): The path to the CSV file where the data will be exported. If not provided, a default file will be generated using the table name.</li>
</ul>

<h4>Example Command:</h4>
<pre><code>pgmonkey pgexport --table public.my_table --connconfig /path/to/config.yaml --export_file /path/to/output.csv</code></pre>

<h4>Notes:</h4>
<ul>
    <li>Both import and export operations will create a config file in the same directory as your file if one does not exist. You should edit it to suit your import/export needs.</li>
</ul>


        <h2>Commands and Results for Code Generation</h2>

<p>Below are examples of how to generate Python code using pgmonkey for different connection types, direct from your config file. Use the <code>--connection-type</code> flag to specify which type of code to generate.</p>

<h3>1. Normal Synchronous Connection</h3>

<pre><code>
$ pgmonkey pgconfig generate-code --filepath config.yaml --connection-type normal
</code></pre>

<p><strong>Generated Code:</strong></p>

<pre><code>
# Example: Normal synchronous connection using pgmonkey
# One config file serves all connection types - just pass the type you need.

from pgmonkey import PGConnectionManager

def main():
    connection_manager = PGConnectionManager()
    config_file_path = 'config.yaml'

    # Get a normal (synchronous) PostgreSQL connection
    connection = connection_manager.get_database_connection(config_file_path, 'normal')

    # Use the connection
    with connection as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT 1;')
            print(cur.fetchone())

if __name__ == "__main__":
    main()
</code></pre>

<h3>2. Pooled Synchronous Connection</h3>

<pre><code>
$ pgmonkey pgconfig generate-code --filepath config.yaml --connection-type pool
</code></pre>

<p><strong>Generated Code:</strong></p>

<pre><code>
# Example: Pooled synchronous connection using pgmonkey
# One config file serves all connection types - just pass the type you need.

from pgmonkey import PGConnectionManager

def main():
    connection_manager = PGConnectionManager()
    config_file_path = 'config.yaml'

    # Get a pooled PostgreSQL connection
    pool_connection = connection_manager.get_database_connection(config_file_path, 'pool')

    # Use the pool - each 'with' block acquires and releases a connection
    with pool_connection as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT 1;')
            print(cur.fetchone())

if __name__ == "__main__":
    main()
</code></pre>

<h3>3. Asynchronous Connection</h3>

<pre><code>
$ pgmonkey pgconfig generate-code --filepath config.yaml --connection-type async
</code></pre>

<p><strong>Generated Code:</strong></p>

<pre><code>
# Example: Asynchronous connection using pgmonkey
# One config file serves all connection types - just pass the type you need.

import asyncio
from pgmonkey import PGConnectionManager

async def main():
    connection_manager = PGConnectionManager()
    config_file_path = 'config.yaml'

    # Get an async PostgreSQL connection
    connection = await connection_manager.get_database_connection(config_file_path, 'async')

    # Use the connection asynchronously
    async with connection as conn:
        async with conn.cursor() as cur:
            await cur.execute('SELECT 1;')
            result = await cur.fetchone()
            print(result)

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>

<h3>4. Asynchronous Pooled Connection</h3>

<pre><code>
$ pgmonkey pgconfig generate-code --filepath config.yaml --connection-type async_pool
</code></pre>

<p><strong>Generated Code:</strong></p>

<pre><code>
# Example: Asynchronous pooled connection using pgmonkey
# One config file serves all connection types - just pass the type you need.

import asyncio
from pgmonkey import PGConnectionManager

async def main():
    connection_manager = PGConnectionManager()
    config_file_path = 'config.yaml'

    # Get an async pooled PostgreSQL connection
    pool_connection = await connection_manager.get_database_connection(config_file_path, 'async_pool')

    # Use the pool - each 'async with' cursor block acquires and releases a connection
    async with pool_connection as conn:
        async with conn.cursor() as cur:
            await cur.execute('SELECT 1;')
            result = await cur.fetchone()
            print(result)

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>


        <p>Example Python connection code direct from your config file is a game changer. This should quickly kickstart your python project by providing the appropriate connection code for sync, async etc...</p>



        <h2>Raspberry Pi Users: Installation via PiWheels</h2>

<p>If you're using a Raspberry Pi and need to manage PostgreSQL connections in Python, <code>pgmonkey</code> is available on <a href="https://www.piwheels.org/project/pgmonkey/">PiWheels</a>, which provides pre-built Python packages optimized for Raspberry Pi.</p>

<h3>Installation</h3>
<p>Installing <code>pgmonkey</code> on Raspberry Pi is straightforward:</p>

<pre><code>pip3 install pgmonkey</code></pre>

<h3>Supported Raspberry Pi OS Versions</h3>
<p><code>pgmonkey</code> has been successfully built for the following Raspberry Pi OS versions:</p>
<ul>
    <li><strong>Bullseye</strong> (Python 3.9)</li>
    <li><strong>Bookworm</strong> (Python 3.11)</li>
</ul>

<h3>Why Use pgmonkey on Raspberry Pi?</h3>
<ul>
    <li>Easily manage PostgreSQL connections using a single YAML configuration.</li>
    <li>Take advantage of async and connection pooling features for performance-critical tasks.</li>
    <li>Run projects efficiently on lower-powered hardware like Raspberry Pi.</li>
</ul>

    </div>

    <footer>
        <p>&copy; 2025 pgmonkey by <a href="https://github.com/RexBytes">RexBytes</a>. <a href="https://github.com/RexBytes/pgmonkey">GitHub</a> | <a href="https://pypi.org/project/pgmonkey/">PyPI</a></p>
    </footer>
</body>
</html>
